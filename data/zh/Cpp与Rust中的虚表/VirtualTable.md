# CPP与RUST中的虚表

谈到虚表, 自然而然的我们会想到cpp中"继承与多态"; 而Rust有意地弱化了面向对象的概念, 转而使用了 **"特征Trait"** 这一更"扁平化"的方式来描述多态. 

### c语言结构体的等号赋值操作

由于CPP选择兼容C, 让我们先来观察C语言中对结构体的操作:
```c
struct Foo {
    int x;
    char c;
    int y;

} foo1; // 定义全局foo1

int main() {
    struct Foo foo2 = {6, 'a', 10}; // 创建另一个局部变量 foo2

    foo1 = foo2; // 使用foo2对foo1进行赋值
}
```

这是一段很基础的代码, 但这已经足够, 我们来观察一下其在未开启优化时生成的汇编代码是如何的:

```asm
foo1:
        .zero   12
main:
        addi    sp,sp,-32
        sd      ra,24(sp)
        sd      s0,16(sp)
        addi    s0,sp,32
        #-------第一行👇------
        li      a5,6
        sw      a5,-32(s0)
        li      a5,97
        sb      a5,-28(s0)
        li      a5,10
        sw      a5,-24(s0)
        #-------第二行👇------
        lui     a5,%hi(foo1)
        addi    a5,a5,%lo(foo1)
        ld      a4,-32(s0)
        sd      a4,0(a5)
        lw      a4,-24(s0)
        sw      a4,8(a5)
        li      a5,0
        #-------------------
        mv      a0,a5
        ld      ra,24(sp)
        ld      s0,16(sp)
        addi    sp,sp,32
        jr      ra
```

即使读不懂也没关系, 在这里快速的为你讲解一下: 首先略过asm中开头和结尾的代码, 只关注我们程序中`main`函数内的两行代码。第一行代码对应了6句asm代码, 每两句为一个组, 对应了为`foo2`结构体的三个赋值操作. 其中第一句`li a5,6`将某个立即数分配到一个寄存器上, 其中寄存器为`a5`, 立即数为`6`; 第二句代码`sw a5,-32(s0)`取`a5`上的1 word数据(1word = 4字节 = 32位)存放到目标地址`-32(s0)`中, 目前`s0`内是当前函数的栈底地址, `-32`代表从`s0`位置向下偏移32字节. 经过三组赋值操作后, 目前栈中的数据看起来是这样的:

```
+---------------------+ <-- s0 (帧指针，原始栈顶 sp_before)
| saved ra    8bytes    | s0-8 到 s0-1 对应24(sp)  |
| --------------------- |
| saved s0    8bytes    | s0-16 到 s0-9 对应16(sp) |
| --------------------- |
| padding     4bytes    | s0-20 到 s0-17           |
| --------------------- |
| local foo2  12bytes   | s0-32 到 s0-20           |
+---------------------+ <-- 当前栈顶 sp = s0-32
```

其中`foo2`内的数据排列为:

```
+----------------------+  \
| int y = 10   4bytes |   |
| ------------------- |   |
| padding      3bytes |   |
| ------------------- |   | --> 12 bytes
| char c = 'a' 1bytes |   |
| ------------------- |   |
| int x = 6    4bytes |   |
+----------------------+  /
```

> padding: 
为了满足指令集的​内存对齐要求​, 这里为8字节对齐.

之前我们略过的开头和结尾的代码, 实际上这部分代码为编译器自动插入的用来保存(还原)需要**被调用者函数**保存(还原)的寄存器内的数据, 函数的返回地址(比如main函数调用fucA后的下一条指令), 保存(恢复)**调用者函数**的栈帧基址, 以及分配(释放)函数栈帧的代码. 由 `addi sp,sp,-32` 可知asm指令为当前`main`函数分配了一个大小为32字节的栈帧(立即将栈指针寄存器地址向下偏移32个字节)

> 函数调用约定: 
在"函数调用另一个函数"这一动作发生时, 产生了调用者和被调用者两个角色, 两个角色有着各自的职责, 比如调用者函数如何向被调用者传递参数, 被调用者如何返回值, 调用双方如何保存当前程序的运行状态, 用以还原函数调用发生前的现场(保存函数调用发生前的寄存器状态).

回到我们的主线上来, 需要关注的是第二行代码所对应的asm指令: 前两个指令将全局变量`foo1`的地址读取到寄存器`a5`当中; `ld a4,-32(s0)` 和 `sd a4,0(a5)`将以`s0`下偏移32字节处为基址的double word数据(8字节数据)加载至`a4`寄存器中, 并存放到`a5`寄存器内地址位置处。这实际上是将当前栈帧内的`foo2.x` 和 `foo3.c with padding` 复制到了全局变量`foo1.x` 和`foo2.c with padding`位置处, 之后以同样的方式将`foo2.y` 复制到了 `foo1.y`位置处。值得一提的是`foo1`可能位于数据段`.bss`内, 该数据段一般存放全局的还未初始化的数据.

> 抽象化的地址空间
需要澄清的是, 我们在编写代码时所考虑的stack, heap, .bss, .text等逻辑段在物理内存中并不存在(或者说并不一一对应), 原因在于操作系统为每一个应用都提供了一个**抽象化且透明的**地址空间, 逻辑段在该地址空间中是连续且一一对应的. 操作系统会进程分配一个**页表**, 将抽象化的地址空间中**所被用到的地址**各自映射到一个物理地址, 这一映射过程以**页**为单位, 由于不同的页转换到物理内存遵循着不同的线性映射, 所以逻辑段不连续于物理内存中. 

![alt text](source/page-table.png)

由此我们得出, **c语言中的结构体的等号赋值操作实际对应了1 : 1的内存复制指令**. 这非常关键, 由于cpp要兼容于c, 所以我们大胆的推测: cpp中的拷贝构造对应了c语言中的1:1内存复制.

### cpp 中的单继承

以下是cpp中单继承的示例, 其中`Derived`类派生自`Base`类:

```cpp
class Base {
   public:
    int base_var;
    Base(int x) : base_var(x) {};
    void base_func() {};
} b1{11};

class Derived : public Base {
   public:
    Derived(int x, int y) : Base(x), derived_var(y) {};

   private:
    long long int derived_var;
    void derived_func() {};
};

int main() {
    Derived d1 = {13, 27}; 

    b1 = d1;
}
```

我们在`main`函数中创建了一个局部变量派生类对象d1, 并使用拷贝构造的方式将它赋值给了局部变量基类b1, 其中发生了"隐式的类型转换".

我们都知道, 在`d1`赋值给`b1`(也可以形象地但不准确地描述为`d1`转化为`b1`)后, 原本存在于d1中的成员变量和函数将不复存在, 无法再使用`b1.derived_var`来访问该值, 这其中又发生了什么呢?让我们来观察一下该段示例代码的汇编代码:

首先是`main`函数的片段:

```asm
main:
    ...
        addi    a5,s0,-32
        li      a2,27
        li      a1,13
        mv      a0,a5
        call    _ZN7DerivedC1Eii
    ...
```

在该`main`函数片段中一共做了3件事情, 第1行和第4行确定了局部变量`d1`在`main`函数栈帧中的基地址, 存储至`a0`寄存器; 第2, 3行将`Derived`类的构造函数参数(两个立即数)添加至`a1`和`a2`中; 第5行则是调用`Derived`类的构造函数.

再来观察`Derived`类的构造函数的汇编指令代码片段:

```asm
_ZN7DerivedC1Eii:
    ...
        mv      a1,a4
        mv      a0,a5
        call    _ZN4BaseC2Ei

        ld      a5,-24(s0)
        lw      a4,-32(s0)
        sd      a4,8(a5)
    ...
```

该片段中, 从上一步骤中的3个参数(参数`13`, 参数`27`, 构建局部变量的基地址)中取出了其中两个: 父类构造函数所需的参数`13` 和基地址, 并先行调用了父类的构造函数`_ZN4BaseC2Ei`, 待其执行完毕后, 从函数栈内取出位于`s0`下偏移24处的双字长局部变量基地址至`a5`, 取出位于`s0`下偏移32处的双字长(8字节)参数`27`至`a4`, 最后, 在基地址偏移量`8`处存放了参数`27`.

> 为什么偏移量为8？
由于基类的Base的大小为4字节, 不满足RISCV的8字节内存对齐要求, 故在Base的数据后添加4字节的padding.

经过此实验我们得出了一个严谨的结论: **派生类的构建是从父类开始的, 并且是先存放父类的成员, 再存放派生类的成员.**

此时`d1`在`main`函数栈帧上的数据排列为:

```
+----------------+---------------+----------------------+
| Base::base_var | Base::padding | Derived::derived_var |
|   (4 bytes)    |   (4 bytes)   |     (8 bytes)        |
+----------------+---------------+----------------------+
|       13       |               |         27           | 
+----------------+---------------+----------------------+
```

可以想象在继承链存在时(长度大于2的继承), 子类的数据排列是如何的: **从继承链最开始依次排列.**

#### 对象切片 (Object Slicing)
事情还没有结束, 接着观察接下来的`main`函数的汇编代码片段:

```asm
b1:
        .zero   4
main:
    ...
        addi    a5,s0,-24
        li      a2,27
        li      a1,13
        mv      a0,a5
        call    _ZN7DerivedC1Eii

        #------------------------#
        lui     a5,%hi(b1)
        lw      a4,-32(s0)
        sw      a4,%lo(b1)(a5)
        #------------------------#
    ...
```

第2行代码从`s0`下偏移32处-即为`d1`的基地址处取出单字长的数据存放至`a4`, 即取出了`d1.base_var`, 第3行代码直接将`a4`的数据拷贝`b1`所在的位置.

`d1`被截断了🤯! 在**编译期**从`d1`转换至`b1`的过程中, `d1.derived_var`被汇编代码直接丢弃, 仿佛以下的情形发生:

```
+----------------+---------------+----------------------+
| Base::base_var | Base::padding | Derived::derived_var |
|   (4 bytes)    |   (4 bytes)   |     (8 bytes)        |
+----------------+---------------+----------------------+
|       13       |               |         27           | 
+----------------+---------------+----------------------+
                           |
                           v
+----------------+---------------+ - - - - - - - - - - -+
| Base::base_var | Base::padding |                      |
|   (4 bytes)    |   (4 bytes)   |                      |
+----------------+---------------|                      |
|       13       |               |                      | 
+----------------+---------------+ - - - - - - - - - - -+

```

这就是单继承下的**对象切片** (是 $[from, to]$ 的截取) , 截断 (是 $[0, to]$ 的截取) 是切片的特例.

> 如标题与上述实验所言, 在单继承时, 数据是从基类到派生类依次排列的, 有一种"设计与实现协调"之美, 但是在多继承下, 事情变得复杂起来, 因为多继承不仅仅是纵向的延申, 还伴有横向的扩展, 这使得类型转换不再是**截断**, 而是**切片**. 在这里我们不讨论多继承下的情况.

### cpp 中的虚函数与虚表

面向对象的另一特性是**多态**, 其允许​不同对象对同一消息 (方法调用) 做出差异化响应, 具体实现依赖于对象的​实际类型​ (动态类型) 而非声明类型 (静态类型) . 其本质是通过**​抽象接口**统一操作, 隐藏具体实现细节, 实现代码的**​松耦合**和**​扩展性**. 

考虑一下代码:

```cpp
class Drawable{                       // 抽象基类为接口
    public:
        bool draw() noexcept {return false;};
};

class Circle: public Drawable{        // 实现类
    public:
        bool draw() noexcept{
            // some process
            return true;
        }
};

bool drawShape(Drawable& obj){        // 库函数
    // some other process
    return obj.draw();
}

int main(){
    Circle c = {};
    auto result = drawShape(c);
}
```

这是一个十分不标准的例子, 但之后我们会修改它. 这段代码中`result`的值是什么呢? 答案就在汇编代码当中:

```asm
drawShape(Drawable&):
    ...
    call    Drawable::draw()    # *Here
    ...
    jr      ra 
```

我们可以看到一切在编译期就已经确定, `drawShape`内部调用的是`Drawable`的`draw()`函数, 所以答案是`false`. 可这并不能满足我们的要求, 我们希望`drawShape`函数可以**动态地**找到实现类对应的方法, 该怎么办呢🤔? 答案就是使用虚函数:

```cpp

class Drawable{                      // 抽象基类为接口
    public:
        virtual bool draw() noexcept {return false;};
};

class Circle: public Drawable{       // 实现类
    public:
        bool draw() noexcept override {
            // some process
            return true;
        }
};

bool drawShape(Drawable& obj){        // 库函数
    // some other process
    return obj.draw();
}

int main(){                         // 入口函数
    Circle c = {};
    drawShape(c);
}
```


当一个类存在虚函数或重写了父类的虚函数时，其头部会内含一个(在多继承下是多个)**虚函数表指针**，它指向**虚函数表**，虚函数表内记录了当前类对于虚函数的实现(重写)函数的地址。

当构建`c`时, 会向其头部写入虚表指针:

```asm
main:
    ...
    lui     a5,%hi(vtable for Circle+16)
    addi    a5,a5,%lo(vtable for Circle+16)         # 16字节偏移量, 
                                                    # 请注意这是编译器优化后的行为
    sd      a5,-24(s0)
    ...

vtable for Circle:
    .dword  0
    .dword  typeinfo for Circle
    .dword  Circle::draw()                         # 在此

```

当执行`drawShape(c);`时:

```asm
main:
    ...
    addi    a5,s0,-24
    mv      a0,a5
    call    drawShape(Drawable&)
    ...
drawShape(Drawable&):
    ...
    ld      a5,-24(s0)                             # 加载对象的地址到 a5
    ld      a5,0(a5)                               # 读取对象的 vptr（虚表指针）
    ld      a5,0(a5)                               # 读取虚表内的第一个条目,
                                                   # 即为Circle::draw()地址
    ld      a0,-24(s0)
    jalr    a5                                     # 调用Circle::draw()
    mv      a5,a0
    ...
```

`main`将`c`的地址(引用)传递给`drawShape`, 其内通过重要的 **`jalr`** (jump an link register) 命令, 直接跳转到Circle::draw()的入口位置进行执行, 并将结果存放至 `a0`。

> **编译器优化对于虚表的影响**
>
> 在正常的多态流程中，对象会保存虚表的地址。在调用虚函数时，程序首先读取对象的虚表指针，之后再通过偏移量访问虚函数表内的某一个特定函数。但在当前的流程中，由于不涉及复杂情况(多继承等)，程序使用保存虚函数内函数指针替代保存虚表的方式，能够减少汇编代码行数。比如在当前示例中，由于`c`直接保存了虚函数表内的`Circle::draw()`的入口地址，所以`drawShape`的汇编代码可精简为:
> ```asm
>    drawShape(Drawable&):
>        ...
>        ld      a5,-24(s0)                             # 对象首地址即为Circle::draw()                  
>        ld      a0,-24(s0)
>        jalr    a5                                     # 调用Circle::draw()
>        mv      a5,a0
>        ..

> **`jalr`** 伪指令
>
> `jalr`是多态的重要实现方式，其用于间接跳转到寄存器中存储的地址，同时保存返回地址到 ra 寄存器。这是 RISC-V 中实现间接函数调用的标准方式。虚函数地址在编译时无法确定（因为多态），必须在运行时从虚表中动态加载到寄存器，再通过 jalr 跳转。